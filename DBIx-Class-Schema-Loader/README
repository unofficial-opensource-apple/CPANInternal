NAME
    DBIx::Class::Schema::Loader - Dynamic definition of a
    DBIx::Class::Schema

SYNOPSIS
      package My::Schema;
      use base qw/DBIx::Class::Schema::Loader/;

      __PACKAGE__->loader_options(
          relationships           => 1,
          constraint              => '^foo.*',
          # debug                 => 1,
      );

      # in seperate application code ...

      use My::Schema;

      my $schema1 = My::Schema->connect( $dsn, $user, $password, $attrs);
      # -or-
      my $schema1 = "My::Schema"; $schema1->connection(as above);

DESCRIPTION
    DBIx::Class::Schema::Loader automates the definition of a
    DBIx::Class::Schema by scanning database table definitions and setting
    up the columns, primary keys, and relationships.

    DBIx::Class::Schema::Loader currently supports only the DBI storage
    type. It has explicit support for DBD::Pg, DBD::mysql, DBD::DB2, and
    DBD::SQLite. Other DBI drivers may function to a greater or lesser
    degree with this loader, depending on how much of the DBI spec they
    implement, and how standard their implementation is. Patches to make
    other DBDs work correctly welcome.

    See DBIx::Class::Schema::Loader::DBI::Writing for notes on writing your
    own vendor-specific subclass for an unsupported DBD driver.

    This module requires DBIx::Class 0.06 or later, and obsoletes the older
    DBIx::Class::Loader.

    This module is designed more to get you up and running quickly against
    an existing database, or to be effective for simple situations, rather
    than to be what you use in the long term for a complex database/project.

    That being said, transitioning your code from a Schema generated by this
    module to one that doesn't use this module should be straightforward and
    painless (as long as you're not using any methods that are now
    deprecated in this document), so don't shy away from it just for fears
    of the transition down the road.

METHODS
  loader_options

    Example in Synopsis above demonstrates a few common arguments. For
    detailed information on all of the arguments, most of which are only
    useful in fairly complex scenarios, see the
    DBIx::Class::Schema::Loader::Base documentation.

    This method is *required* at this time, for backwards compatibility
    reasons. If you do not wish to change any options, just call it with an
    empty argument list during schema class initialization.

    Setting these options explicitly via this method after calling
    `connection' is deprecated and will stop working in version 0.04000. For
    now the code merely warns about this condition.

    The preferred way of doing things is to either call `loader_options'
    before any connection is made, or embed the `loader_options' in the
    connection information itself as shown below.

  connection

    See DBIx::Class::Schema for basic usage.

    If the final argument is a hashref, and it contains a key
    `loader_options', that key will be deleted, and its value will be used
    for the loader options, just as if set via the loader_options method
    above.

    The actual auto-loading operation (the heart of this module) will be
    invoked as soon as the connection information is defined.

  clone

    See DBIx::Class::Schema.

  dump_to_dir

    Argument: directory name.

    Calling this as a class method on either DBIx::Class::Schema::Loader or
    any derived schema class will cause all affected schemas to dump manual
    versions of themselves to the named directory when they are loaded. In
    order to be effective, this must be set before defining a connection on
    this schema class or any derived object (as the loading happens as soon
    as both a connection and loader_options are set, and only once per
    class).

    See DBIx::Class::Schema::Loader::Base for more details on the dumping
    mechanism.

    This can also be set at module import time via the import option
    `dump_to_dir:/foo/bar' to DBIx::Class::Schema::Loader, where `/foo/bar'
    is the target directory.

    Examples:

        # My::Schema isa DBIx::Class::Schema::Loader, and has connection info
        #   hardcoded in the class itself:
        perl -MDBIx::Class::Schema::Loader=dump_to_dir:/foo/bar -MMy::Schema -e1

        # Same, but no hard-coded connection, so we must provide one:
        perl -MDBIx::Class::Schema::Loader=dump_to_dir:/foo/bar -MMy::Schema -e 'My::Schema->connection("dbi:Pg:dbname=foo", ...)'

        # Or as a class method, as long as you get it done *before* defining a
        #  connection on this schema class or any derived object:
        use My::Schema;
        My::Schema->dump_to_dir('/foo/bar');
        My::Schema->connection(........);

        # Or as a class method on the DBIx::Class::Schema::Loader itself, which affects all
        #   derived schemas
        use My::Schema;
        use My::OtherSchema;
        DBIx::Class::Schema::Loader->dump_to_dir('/foo/bar');
        My::Schema->connection(.......);
        My::OtherSchema->connection(.......);

        # Another alternative to the above:
        use DBIx::Class::Schema::Loader qw| dump_to_dir:/foo/bar |;
        use My::Schema;
        use My::OtherSchema;
        My::Schema->connection(.......);
        My::OtherSchema->connection(.......);

  make_schema_at

    This simple function allows one to create a Loader-based schema
    in-memory on the fly without any on-disk class files of any kind. When
    used with the `dump_directory' option, you can use this to generate a
    rough draft manual schema from a dsn without the intermediate step of
    creating a physical Loader-based schema class.

    The return value is the input class name.

    This function can be exported/imported by the normal means, as
    illustrated in these Examples:

        # Simple example, creates as a new class 'New::Schema::Name' in
        #  memory in the running perl interpreter.
        use DBIx::Class::Schema::Loader qw/ make_schema_at /;
        make_schema_at(
            'New::Schema::Name',
            { relationships => 1, debug => 1 },
            [ 'dbi:Pg:dbname="foo"','postgres' ],
        );

        # Complex: dump loaded schema to disk, all from the commandline:
        perl -MDBIx::Class::Schema::Loader=make_schema_at,dump_to_dir:./lib -e 'make_schema_at("New::Schema::Name", { relationships => 1 }, [ "dbi:Pg:dbname=foo","postgres" ])'

        # Same, but inside a script, and using a different way to specify the
        # dump directory:
        use DBIx::Class::Schema::Loader qw/ make_schema_at /;
        make_schema_at(
            'New::Schema::Name',
            { relationships => 1, debug => 1, dump_directory => './lib' },
            [ 'dbi:Pg:dbname="foo"','postgres' ],
        );

EXAMPLE
    Using the example in DBIx::Class::Manual::ExampleSchema as a basis
    replace the DB::Main with the following code:

      package DB::Main;

      use base qw/DBIx::Class::Schema::Loader/;

      __PACKAGE__->loader_options(
          relationships => 1,
          debug         => 1,
      );
      __PACKAGE__->connection('dbi:SQLite:example.db');

      1;

    and remove the Main directory tree (optional). Every thing else should
    work the same

DEPRECATED METHODS
    You don't need to read anything in this section unless you're upgrading
    code that was written against pre-0.03 versions of this module. This
    version is intended to be backwards-compatible with pre-0.03 code, but
    will issue warnings about your usage of deprecated features/methods.

    All of these deprecated methods will dissappear in version 0.04000, and
    converting code that uses these methods should be trivial.

  load_from_connection

    This deprecated method is now roughly an alias for loader_options.

    For now, using this method will invoke the legacy behavior for backwards
    compatibility, and merely emit a warning about upgrading your code.

    It also reverts the default inflection scheme to use Lingua::EN::Inflect
    just like pre-0.03 versions of this module did.

    You can force these legacy inflections with the option
    DBIx::Class::Schema::Loader::Base, even after switch over to the
    preferred loader_options way of doing things. That option will not go
    away until at least 0.05.

    See the source of this method for more details.

  loader

    This is an accessor in the generated Schema class for accessing the
    DBIx::Class::Schema::Loader::Base -based loader object that was used
    during construction. See the DBIx::Class::Schema::Loader::Base docs for
    more information on the available loader methods there.

    This accessor is deprecated. Do not use it. Anything you can get from
    `loader', you can get via the normal DBIx::Class::Schema methods, and
    your code will be more robust and forward-thinking for doing so.

    If you're already using `loader' in your code, make an effort to get rid
    of it. If you think you've found a situation where it is necessary, let
    me know and we'll see what we can do to remedy that situation.

    In some future version, this accessor *will* disappear. It was
    apparently quite a design/API mistake to ever have exposed it to
    user-land in the first place, all things considered.

KNOWN ISSUES
  Multiple Database Schemas

    Currently the loader is limited to working within a single schema (using
    the database vendors' definition of "schema"). If you have a
    multi-schema database with inter-schema relationships (which is easy to
    do in PostgreSQL or DB2 for instance), you only get to automatically
    load the tables of one schema, and any relationships to tables in other
    schemas will be silently ignored.

    At some point in the future, an intelligent way around this might be
    devised, probably by allowing the `db_schema' option to be an arrayref
    of schemas to load.

    In "normal" DBIx::Class::Schema usage, manually-defined source classes
    and relationships have no problems crossing vendor schemas.

AUTHOR
    Brandon Black, `blblack@gmail.com'

    Based on DBIx::Class::Loader by Sebastian Riedel

    Based upon the work of IKEBE Tomohiro

THANK YOU
    Matt S Trout, all of the #dbix-class folks, and everyone who's ever sent
    in a bug report or suggestion.

LICENSE
    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

SEE ALSO
    DBIx::Class, DBIx::Class::Manual::ExampleSchema

