NAME
    Module::Build - Build and install Perl modules

SYNOPSIS
    Standard process for building & installing modules:

       perl Build.PL
       ./Build
       ./Build test
       ./Build install

    Or, if you're on a platform (like DOS or Windows) that doesn't like the "./"
    notation, you can do this:

       perl Build.PL
       perl Build
       perl Build test
       perl Build install

DESCRIPTION
    This is a beta version of a new module I've been working on,
    "Module::Build". It is meant to be a replacement for "ExtUtils::MakeMaker".

    To install "Module::Build", and any other module that uses "Module::Build"
    for its installation process, do the following:

      perl Build.PL       # 'Build.PL' script creates the 'Build' script
      ./Build             # Need ./ to ensure we're using this "Build" script
      ./Build test        # and not another one that happens to be in the PATH
      ./Build install

    This illustrates initial configuration and the running of three 'actions'.
    In this case the actions run are 'build' (the default action), 'test', and
    'install'. Actions defined so far include:

      build                          help        
      clean                          install     
      diff                           manifest    
      dist                           manifypods  
      distcheck                      realclean   
      distclean                      skipcheck   
      distdir                        test        
      distsign                       testdb      
      disttest                       versioninstall
      fakeinstall

    You can run the 'help' action for a complete list of actions.

    When creating a "Build.PL" script for a module, something like the following
    code will typically be used:

      use Module::Build;
      my $build = new Module::Build
        (
         module_name => 'Foo::Bar',
         license => 'perl',
         requires => {
                      perl           => '5.6.1',
                      Some::Module   => '1.23',
                      Other::Module  => '>= 1.2, != 1.5, < 2.0',
                     },
        );
      $build->create_build_script;

    A simple module could get away with something as short as this for its
    "Build.PL" script:

      use Module::Build;
      Module::Build->new(
         module_name => 'Foo::Bar',
         license => 'perl',
      )->create_build_script;

    The model used by "Module::Build" is a lot like the "MakeMaker" metaphor,
    with the following correspondences:

       In ExtUtils::MakeMaker               In Module::Build
      ------------------------             ---------------------------
       Makefile.PL (initial script)         Build.PL (initial script)
       Makefile (a long Makefile)           Build (a short perl script)
       <none>                               _build/ (for saving state info)

    Any customization can be done simply by subclassing "Module::Build" and
    adding a method called (for example) "ACTION_test", overriding the default
    'test' action. You could also add a method called "ACTION_whatever", and
    then you could perform the action "Build whatever".

    For information on providing backward compatibility with
    "ExtUtils::MakeMaker", see the Module::Build::Compat manpage.

METHODS
    I list here some of the most important methods in "Module::Build". Normally
    you won't need to deal with these methods unless you want to subclass
    "Module::Build". But since one of the reasons I created this module in the
    first place was so that subclassing is possible (and easy), I will certainly
    write more docs as the interface stabilizes.

    new()
        Creates a new Module::Build object. Arguments to the new() method are
        listed below. Most arguments are optional, but you must provide either
        the "module_name" argument, or "dist_name" and one of "dist_version" or
        "dist_version_from". In other words, you must provide enough information
        to determine both a distribution name and version.

        module_name
            The "module_name" is a shortcut for setting default values of
            "dist_name" and "dist_version_from", reflecting the fact that the
            majority of CPAN distributions are centered around one "main"
            module. For instance, if you set "module_name" to "Foo::Bar", then
            "dist_name" will default to "Foo-Bar" and "dist_version_from" will
            default to "lib/Foo/Bar.pm". "dist_version_from" will in turn be
            used to set "dist_version".

            Setting "module_name" won't override a "dist_*" parameter you
            specify explicitly.

        dist_name
            Specifies the name for this distribution. Most authors won't need to
            set this directly, they can use "module_name" to set "dist_name" to
            a reasonable default. However, some agglomerative distributions like
            "libwww-perl" or "bioperl" have names that don't correspond directly
            to a module name, so "dist_name" can be set independently.

        dist_version
            Specifies a version number for the distribution. See "module_name"
            or "dist_version_from" for ways to have this set automatically from
            a "$VERSION" variable in a module. One way or another, a version
            number needs to be set.

        dist_version_from
            Specifies a file to look for the distribution version in. Most
            authors won't need to set this directly, they can use "module_name"
            to set it to a reasonable default.

            The version is extracted from the specified file according to the
            same rules as "ExtUtils::MakeMaker" and "CPAN.pm". It involves
            finding the first line that matches the regular expression

               /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/

            , eval()-ing that line, then checking the value of the "$VERSION"
            variable. Quite ugly, really, but all the modules on CPAN depend on
            this process, so there's no real opportunity to change to something
            better.

        license
            Specifies the licensing terms of your distribution. Valid options
            include:

            perl
                The distribution may be copied and redistributed under the same
                terms as perl itself (this is by far the most common licensing
                option for modules on CPAN). This is a dual license, in which
                the user may choose between either the GPL or the Artistic
                license.

            gpl The distribution is distributed under the terms of the Gnu
                Public License.

            artistic
                The distribution is licensed under the Artistic License, as
                specified by the Artistic file in the standard perl
                distribution.

            restrictive
                The distribution may not be redistributed without special
                arrangement with the author.

            Note that you must still include the terms of your license in your
            documentation - this field only lets automated tools figure out your
            licensing restrictions. Humans still need something to read.

            It is a fatal error to use a license other than the ones mentioned
            above. This is not because I wish to impose licensing terms on you -
            please let me know if you would like another license option to be
            added to the list. You may also use a license type of "unknown" if
            you don't wish to specify your terms (but this is usually not a good
            idea for you to do!).

            I just started out with a small set of licenses to keep things
            simple, figuring I'd let people with actual working knowledge in
            this area tell me what to do. So if that's you, drop me a line.

        requires
            An optional "requires" argument specifies any module prerequisites
            that the current module depends on. The prerequisites are given in a
            hash reference, where the keys are the module names and the values
            are version specifiers:

             requires => {Foo::Module => '2.4',
                          Bar::Module => 0,
                          Ken::Module => '>= 1.2, != 1.5, < 2.0',
                          perl => '5.6.0'},

            These four version specifiers have different effects. The value
            "'2.4'" means that at least version 2.4 of "Foo::Module" must be
            installed. The value "0" means that any version of "Bar::Module" is
            acceptable, even if "Bar::Module" doesn't define a version. The more
            verbose value "'>= 1.2, != 1.5, < 2.0'" means that "Ken::Module"'s
            version must be at least 1.2, less than 2.0, and not equal to 1.5.
            The list of criteria is separated by commas, and all criteria must
            be satisfied.

            A special "perl" entry lets you specify the versions of the Perl
            interpreter that are supported by your module. The same version
            dependency-checking semantics are available, except that we also
            understand perl's new double-dotted version numbers.

            One note: currently "Module::Build" doesn't actually *require* the
            user to have dependencies installed, it just strongly urges. In the
            future we may require it. There's now a "recommends" section for
            things that aren't absolutely required.

            Automated tools like CPAN.pm should refuse to install a module if
            one of its dependencies isn't satisfied, unless a "force" command is
            given by the user. If the tools are helpful, they should also offer
            to install the dependencies.

            A sysnonym for "requires" is "prereq", to help succour people
            transitioning from "ExtUtils::MakeMaker". The "requires" term is
            preferred, but the "prereq" term will remain valid in future
            distributions.

        recommends
            This is just like the "requires" argument, except that modules
            listed in this section aren't essential, just a good idea. We'll
            just print a friendly warning if one of these modules aren't found,
            but we'll continue running.

            If a module is recommended but not required, all tests should still
            pass if the module isn't installed. This may mean that some tests
            will be skipped if recommended dependencies aren't present.

            Automated tools like CPAN.pm should inform the user when recommended
            modules aren't installed, and it should offer to install them if it
            wants to be helpful.

        build_requires
            Modules listed in this section are necessary to build and install
            the given module, but are not necessary for regular usage of it.
            This is actually an important distinction - it allows for tighter
            control over the body of installed modules, and facilitates correct
            dependency checking on binary/packaged distributions of the module.

        conflicts
            Modules listed in this section conflict in some serious way with the
            given module. "Module::Build" will refuse to install the given
            module if

        c_source
            An optional "c_source" argument specifies a directory which contains
            C source files that the rest of the build may depend on. Any ".c"
            files in the directory will be compiled to object files. The
            directory will be added to the search path during the compilation
            and linking phases of any C or XS files.

        scripts
            An array reference containing a list of files that should be
            installed as perl scripts when the module is installed.

        autosplit
            An optional "autosplit" argument specifies a file which should be
            run through the "Autosplit::autosplit()" function. In general I
            don't consider this a great idea, and I may even go so far as to
            remove this feature later. Let me know if I shouldn't.

        dynamic_config
            A boolean flag indicating whether the Build.PL file must be
            executed, or whether this module can be built, tested and installed
            solely from consulting its metadata file. The default value is 0,
            reflecting the fact that "most" of the modules on CPAN just need to
            be copied from one place to another. The main reason to set this to
            a true value is that your module performs some dynamic configuration
            as part of its build/install process.

            Currently "Module::Build" doesn't actually do anything with this
            flag - it's probably going to be up to tools like "CPAN.pm" to do
            something useful with it. It can potentially bring lots of security,
            packaging, and convenience improvements.

        sign
            If a true value is specified for this parameter, "Module::Signature"
            will be used (via the 'distsign' action) to create a SIGNATURE file
            for your distribution during the 'distdir' action. The default is
            false. In the future, the default may change to true if you have
            "Module::Signature" installed on your system.

    create_build_script()
        Creates an executable script called "Build" in the current directory
        that will be used to execute further user actions. This script is
        roughly analogous (in function, not in form) to the Makefile created by
        "ExtUtils::MakeMaker". This method also creates some temporary data in a
        directory called "_build/". Both of these will be removed when the
        "realclean" action is performed.

    add_to_cleanup()
        A "Module::Build" method may call "$self->add_to_cleanup(@files)" to
        tell "Module::Build" that certain files should be removed when the user
        performs the "Build clean" action. I decided to make this a dynamic
        method, rather than a static list of files, because these static lists
        can get difficult to manage. I preferred to keep the responsibility for
        registering temporary files close to the code that creates them.

    resume()
        You'll probably never call this method directly, it's only called from
        the auto-generated "Build" script. The "new()" method is only called
        once, when the user runs "perl Build.PL". Thereafter, when the user runs
        "Build test" or another action, the "Module::Build" object is created
        using the "resume()" method.

    dispatch()
        This method is also called from the auto-generated "Build" script. It
        parses the command-line arguments into an action and an argument list,
        then calls the appropriate routine to handle the action. Currently
        (though this may change), an action "foo" will invoke the "ACTION_foo"
        method. All arguments (including everything mentioned in the ACTIONS
        manpage below) are contained in the "$self->{args}" hash reference.

    os_type()
        If you're subclassing Module::Build and some code needs to alter its
        behavior based on the current platform, you may only need to know
        whether you're running on Windows, Unix, MacOS, VMS, etc. and not the
        fine-grained value of Perl's "$^O" variable. The "os_type()" method will
        return a string like "Windows", "Unix", "MacOS", "VMS", or whatever is
        appropriate. If you're running on an unknown platform, it will return
        "undef" - there shouldn't be many unknown platforms though.

    prereq_failures()
        Returns a data structure containing information about any failed
        prerequisites (of any of the types described above), or "undef" if all
        prerequisites are met.

        The data structure returned is a hash reference. The top level keys are
        the type of prerequisite failed, one of "requires", "build_requires",
        "conflicts", or "recommends". The associated values are hash references
        whose keys are the names of required (or conflicting) modules. The
        associated values of those are hash references indicating some
        information about the failure. For example:

         {
          have => '0.42',
          need => '0.59',
          message => 'Version 0.42 is installed, but we need version 0.59',
         }

        or

         {
          have => '<none>',
          need => '0.59',
          message => 'Prerequisite Foo isn't installed',
         }

        This hash has the same structure as the hash returned by the
        "check_installed_status()" method, except that in the case of
        "conflicts" dependencies we change the "need" key to "conflicts" and
        construct a proper message.

        Examples:

          # Check a required dependency on Foo::Bar
          if ( $m->prereq_failures->{requires}{Foo::Bar} ) { ...

          # Check whether there were any failures
          if ( $m->prereq_failures ) { ...
  
          # Show messages for all failures
          my $failures = $m->prereq_failures;
          while (my ($type, $list) = each %$failures) {
            while (my ($name, $hash) = each %$list) {
              print "Failure for $name: $hash->{message}\n";
            }
          }

    check_installed_status($module, $version)
        This method returns a hash reference indicating whether a version
        dependency on a certain module is satisfied. The "$module" argument is
        given as a string like ""Data::Dumper"" or ""perl"", and the "$version"
        argument can take any of the forms described in the requires manpage
        above. This allows very fine-grained version checking.

        The returned hash reference has the following structure:

         {
          ok => $whether_the_dependency_is_satisfied,
          have => $version_already_installed,
          need => $version_requested, # Same as incoming $version argument
          message => $informative_error_message,
         }

        If no version of "$module" is currently installed, the "have" value will
        be the string ""<none>"". Otherwise the "have" value will simply be the
        version of the installed module. Note that this means that if "$module"
        is installed but doesn't define a version number, the "have" value will
        be "undef" - this is why we don't use "undef" for the case when
        "$module" isn't installed at all.

    check_installed_version($module, $version)
        Like "check_installed_status()", but simply returns true or false
        depending on whether module "$module" statisfies the dependency
        "$version".

        If the check succeeds, the return value is the actual version of
        "$module" installed on the system. This allows you to do the following:

         my $installed = $m->check_installed_version('DBI', '1.15');
         if ($installed) {
           print "Congratulations, version $installed of DBI is installed.\n";
         } else {
           die "Sorry, you must install DBI.\n";
         }

        If the check fails, we return false and set "$@" to an informative error
        message.

        If "$version" is any nontrue value (notably zero) and any version of
        "$module" is installed, we return true. In this case, if "$module"
        doesn't define a version, or if its version is zero, we return the
        special value "0 but true", which is numerically zero, but logically
        true.

        In general you might prefer to use "check_installed_status" if you need
        detailed information, or this method if you just need a yes/no answer.

    prompt()
        Asks the user a question and returns their response as a string. The
        first argument specifies the message to display to the user (for
        example, ""Where do you keep your money?""). The second argument, which
        is optional, specifies a default answer (for example, ""wallet""). The
        user will be asked the question once.

        If the current session doesn't seem to be interactive (i.e. if "STDIN"
        and "STDOUT" look like they're attached to files or something, not
        terminals), we'll just use the default without letting the user provide
        an answer.

    y_n()
        Asks the user a yes/no question using "prompt()" and returns true or
        false accordingly. The user will be asked the question repeatedly until
        they give an answer that looks like "yes" or "no".

        The first argument specifies the message to display to the user (for
        example, ""Shall I invest your money for you?""), and the second
        argument specifies the default answer (for example, ""y"").

        Note that the default is specified as a string like ""y"" or ""n"", and
        the return value is a Perl boolean value like 1 or 0. I thought about
        this for a while and this seemed like the most useful way to do it.

    scripts()
        Returns an array reference specifying the perl script files to be
        installed. This corresponds to the "scripts" parameter to the "new()"
        method. With an optional argument, this parameter may be set
        dynamically.

    base_dir()
        Returns a string containing the root-level directory of this build, i.e.
        where the "Build.PL" script and the "lib" directory can be found. This
        is usually the same as the current working directory, because the
        "Build" script will "chdir()" into this directory as soon as it begins
        execution.

ACTIONS
    There are some general principles at work here. First, each task when
    building a module is called an "action". These actions are listed above;
    they correspond to the building, testing, installing, packaging, etc. tasks.

    Second, arguments are processed in a very systematic way. Arguments are
    always key=value pairs. They may be specified at "perl Build.PL" time (i.e.
    "perl Build.PL sitelib=/my/secret/place"), in which case their values last
    for the lifetime of the "Build" script. They may also be specified when
    executing a particular action (i.e. "Build test verbose=1"), in which case
    their values last only for the lifetime of that command. Per-action
    command-line parameters take precedence over parameters specified at "perl
    Build.PL" time.

    The build process also relies heavily on the "Config.pm" module, and all the
    key=value pairs in "Config.pm" are available in

    "$self->{config}". If the user wishes to override any of the values in
    "Config.pm", she may specify them like so:

      perl Build.PL config='siteperl=/foo perlpath=/wacky/stuff'

    Not the greatest interface, I'm looking for alternatives. Speak now! Maybe:

      perl Build.PL config-siteperl=/foo config-perlpath=/wacky/stuff

    or something.

    The following build actions are provided by default.

    help
        This action will simply print out a message that is meant to help you
        use the build process. It will show you a list of available build
        actions too.

    build
        If you run the "Build" script without any arguments, it runs the "build"
        action.

        This is analogous to the MakeMaker 'make all' target. By default it just
        creates a "blib/" directory and copies any ".pm" and ".pod" files from
        your "lib/" directory into the "blib/" directory. It also compiles any
        ".xs" files from "lib/" and places them in "blib/". Of course, you need
        a working C compiler (probably the same one that built perl itself) for
        this to work properly.

        The "build" action also runs any ".PL" files in your lib/ directory.
        Typically these create other files, named the same but without the ".PL"
        ending. For example, a file lib/Foo/Bar.pm.PL could create the file
        lib/Foo/Bar.pm. The ".PL" files are processed first, so any ".pm" files
        (or other kinds that we deal with) will get copied correctly.

        If your ".PL" scripts don't create any files, or if they create files
        with unexpected names, or even if they create multiple files, you should
        tell us that so that we can clean up properly after these created files.
        Use the "PL_files" parameter to "new()":

         PL_files => { 'lib/Foo/Bar_pm.PL' => 'lib/Foo/Bar.pm',
                       'lib/something.PL'  => ['/lib/something', '/lib/else'],
                       'lib/funny.PL'      => [] }

        Note that in contrast to MakeMaker, the "build" action only (currently)
        handles ".pm", ".pod", ".PL", and ".xs" files. They must all be in the
        "lib/" directory, in the directory structure that they should have when
        installed. We also handle ".c" files that can be in the place of your
        choosing - see the "c_source" argument to "new()".

        The ".xs" support is currently in alpha. Please let me know whether it
        works for you.

    test
        This will use "Test::Harness" to run any regression tests and report
        their results. Tests can be defined in the standard places: a file
        called "test.pl" in the top-level directory, or several files ending
        with ".t" in a "t/" directory.

        If you want tests to be 'verbose', i.e. show details of test execution
        rather than just summary information, pass the argument "verbose=1".

        If you want to run tests under the perl debugger, pass the argument
        "debugger=1".

        In addition, if a file called "visual.pl" exists in the top-level
        directory, this file will be executed as a Perl script and its output
        will be shown to the user. This is a good place to put speed tests or
        other tests that don't use the "Test::Harness" format for output.

        To override the choice of tests to run, you may pass a "test_files"
        argument whose value is a whitespace-separated list of test scripts to
        run. This is especially useful in development, when you only want to run
        a single test to see whether you've squashed a certain bug yet:

         ./Build test verbose=1 test_files=t/something_failing.t

    testdb
        This is a synonym for the 'test' action with the "debugger=1" argument.

    clean
        This action will clean up any files that the build process may have
        created, including the "blib/" directory (but not including the
        "_build/" directory and the "Build" script itself).

    realclean
        This action is just like the "clean" action, but also removes the
        "_build" directory and the "Build" script. If you run the "realclean"
        action, you are essentially starting over, so you will have to re-create
        the "Build" script again.

    diff
        This action will compare the files about to be installed with their
        installed counterparts. For .pm and .pod files, a diff will be shown
        (this currently requires a 'diff' program to be in your PATH). For other
        files like compiled binary files, we simply report whether they differ.

        A "flags" parameter may be passed to the action, which will be passed to
        the 'diff' program. Consult your 'diff' documentation for the parameters
        it will accept - a good one is "-u":

         ./Build diff flags=-u

    install
        This action will use "ExtUtils::Install" to install the files from
        "blib/" into the correct system-wide module directory. The directory is
        determined from the "sitelib" entry in the "Config.pm" module. To
        install into a different directory, pass a different value for the
        "sitelib" parameter, like so:

         Build install sitelib=/my/secret/place/

        Alternatively, you could specify the "sitelib" parameter when you run
        the "Build.PL" script:

         perl Build.PL sitelib=/my/secret/place/

        Under normal circumstances, you'll need superuser privileges to install
        into your system's default "sitelib" directory.

        If you want to install everything into a temporary directory first (for
        instance, if you want to create a directory tree that a package manager
        like "rpm" or "dpkg" could create a package from), you can use the
        "destdir" parameter:

         perl Build.PL destdir=/tmp/foo

        or

         Build install destdir=/tmp/foo

        This will effectively install to "$destdir/$sitelib",
        "$destdir/$sitearch", and the like, except that it will use "File::Spec"
        to make the pathnames work correctly on whatever platform you're
        installing on.

        If you want the installation process to look around in "@INC" for other
        versions of the stuff you're installing and try to delete it, you can
        use the "uninst" parameter:

         Build install uninst=1

        This can be a good idea, as it helps prevent multiple versions of a
        module from being present on your system, which can be a confusing
        situation indeed.

    fakeinstall
        This is just like the "install" action, but it won't actually do
        anything, it will just report what it *would* have done if you had
        actually run the "install" action.

    versioninstall
        ** Note: since "only.pm" is so new, and since we just recently added
        support for it here too, this feature is to be considered experimental.
        **

        If you have the "only.pm" module installed on your system, you can use
        this action to install a module into the version-specific library trees.
        This means that you can have several versions of the same module
        installed and "use" a specific one like this:

         use only MyModule => 0.55;

        To override the default installation libraries in "only::config",
        specify the "versionlib" parameter when you run the "Build.PL" script:

         perl Build.PL versionlib=/my/version/place/

        To override which version the module is installed as, specify the
        "versionlib" parameter when you run the "Build.PL" script:

         perl Build.PL version=0.50

        See the "only.pm" documentation for more information on version-specific
        installs.

    manifest
        This is an action intended for use by module authors, not people
        installing modules. It will bring the MANIFEST up to date with the files
        currently present in the distribution. You may use a MANIFEST.SKIP file
        to exclude certain files or directories from inclusion in the MANIFEST.
        MANIFEST.SKIP should contain a bunch of regular expressions, one per
        line. If a file in the distribution directory matches any of the regular
        expressions, it won't be included in the MANIFEST.

        The following is a reasonable MANIFEST.SKIP starting point, you can add
        your own stuff to it:

           ^_build
           ^Build$
           ^blib
           ~$
           \.bak$
           ^MANIFEST\.SKIP$
           CVS

        See the the distcheck manpage and the skipcheck manpage actions if you
        want to find out what the "manifest" action would do, without actually
        doing anything.

    dist
        This action is helpful for module authors who want to package up their
        module for distribution through a medium like CPAN. It will create a
        tarball of the files listed in MANIFEST and compress the tarball using
        GZIP compression.

    distsign
        Uses "Module::Signature" to create a SIGNATURE file for your
        distribution.

    distcheck
        Reports which files are in the build directory but not in the MANIFEST
        file, and vice versa. (See the manifest manpage for details)

    skipcheck
        Reports which files are skipped due to the entries in the MANIFEST.SKIP
        file (See the manifest manpage for details)

    distclean
        Performs the 'realclean' action and then the 'distcheck' action.

    distdir
        Creates a directory called "$(DISTNAME)-$(VERSION)" (if that directory
        already exists, it will be removed first). Then copies all the files
        listed in the MANIFEST file to that directory. This directory is what
        people will see when they download your distribution and unpack it.

        While performing the 'distdir' action, a file containing various bits of
        "metadata" will be created. The metadata includes the module's name,
        version, dependencies, license, and the "dynamic_config" flag. This file
        is created as META.yaml in YAML format, so you must have the "YAML"
        module installed in order to create it. You should also ensure that the
        META.yaml file is listed in your MANIFEST - if it's not, a warning will
        be issued.

    disttest
        Performs the 'distdir' action, then switches into that directory and
        runs a "perl Build.PL", followed by the 'build' and 'test' actions in
        that directory.

AUTOMATION
    One advantage of Module::Build is that since it's implemented as Perl
    methods, you can invoke these methods directly if you want to install a
    module non-interactively. For instance, the following Perl script will
    invoke the entire build/install procedure:

     my $m = new Module::Build (module_name => 'MyModule');
     $m->dispatch('build');
     $m->dispatch('test');
     $m->dispatch('install');

    If any of these steps encounters an error, it will throw a fatal exception.

    You can also pass arguments as part of the build process:

     my $m = new Module::Build (module_name => 'MyModule');
     $m->dispatch('build');
     $m->dispatch('test', verbose => 1);
     $m->dispatch('install', sitelib => '/my/secret/place/');

    Building and installing modules in this way skips creating the "Build"
    script.

STRUCTURE
    Module::Build creates a class hierarchy conducive to customization. Here is
    the parent-child class hierarchy in classy ASCII art:

       /--------------------\
       |   Your::Parent     |  (If you subclass Module::Build)
       \--------------------/
                |
                |
       /--------------------\  (Doesn't define any functionality
       |   Module::Build    |   of its own - just figures out what
       \--------------------/   other modules to load.)
                |
                |
       /-----------------------------------\  (Some values of $^O may
       |   Module::Build::Platform::$^O    |   define specialized functionality.
       \-----------------------------------/   Otherwise it's ...::Default, a
                |                              pass-through class.)
                |
       /--------------------------\
       |   Module::Build::Base    |  (Most of the functionality of 
       \--------------------------/   Module::Build is defined here.)

SUBCLASSING
    Right now, there are two ways to subclass Module::Build. The first way is to
    create a regular module (in a ".pm" file) that inherits from Module::Build,
    and use that module's class instead of using Module::Build directly:

      ------ in Build.PL: ----------
      #!/usr/bin/perl
  
      use lib qw(/nonstandard/library/path);
      use My::Builder;  # Or whatever you want to call it
  
      my $m = My::Builder->new(module_name => 'Next::Big::Thing');
      $m->create_build_script;

    This is relatively straightforward, and is the best way to do things if your
    My::Builder class contains lots of code. The "create_build_script()" method
    will ensure that the current value of "@INC" (including the
    "/nonstandard/library/path") is propogated to the Build script, so that
    My::Builder can be found when running build actions.

    For very small additions, Module::Build provides a "subclass()" method that
    lets you subclass Module::Build more conveniently, without creating a
    separate file for your module:

      ------ in Build.PL: ----------
      #!/usr/bin/perl
  
      my $class = Module::Build->subclass
        (
         class => 'My::Builder',
         code => q{
          sub ACTION_foo {
            print "I'm fooing to death!\n";
          }
         },
        );
  
      my $m = $class->new(module_name => 'Module::Build');
      $m->create_build_script;

    Behind the scenes, this actually does create a ".pm" file, since the code
    you provide must persist after Build.PL is run if it is to be very useful.

MOTIVATIONS
    There are several reasons I wanted to start over, and not just fix what I
    didn't like about MakeMaker:

    *   I don't like the core idea of MakeMaker, namely that "make" should be
        involved in the build process. Here are my reasons:

        +   When a person is installing a Perl module, what can you assume about
            their environment? Can you assume they have "make"? No, but you can
            assume they have some version of Perl.

        +   When a person is writing a Perl module for intended distribution,
            can you assume that they know how to build a Makefile, so they can
            customize their build process? No, but you can assume they know
            Perl, and could customize that way.

        For years, these things have been a barrier to people getting the
        build/install process to do what they want.

    *   There are several architectural decisions in MakeMaker that make it very
        difficult to customize its behavior. For instance, when using MakeMaker
        you do "use MakeMaker", but the object created in "WriteMakefile()" is
        actually blessed into a package name that's created on the fly, so you
        can't simply subclass "ExtUtils::MakeMaker". There is a workaround "MY"
        package that lets you override certain MakeMaker methods, but only
        certain explicitly predefined (by MakeMaker) methods can be overridden.
        Also, the method of customization is very crude: you have to modify a
        string containing the Makefile text for the particular target.

    *   It is risky to make major changes to MakeMaker, since it does so many
        things, is so important, and generally works. "Module::Build" is an
        entirely seperate package so that I can work on it all I want, without
        worrying about backward compatibility.

    *   Finally, Perl is said to be a language for system administration. Could
        it really be the case that Perl isn't up to the task of building and
        installing software? Even if that software is a bunch of stupid little
        ".pm" files that just need to be copied from one place to another? Are
        you getting riled up yet??

    Please contact me if you have any questions or ideas.

TO DO
    The current method of relying on time stamps to determine whether a derived
    file is out of date isn't likely to scale well, since it requires tracing
    all dependencies backward, it runs into problems on NFS, and it's just
    generally flimsy. It would be better to use an MD5 signature or the like, if
    available. See "cons" for an example.

    The current dependency-checking is prone to errors. You can make 'widowed'
    files by doing "Build", "perl Build.PL", and then "Build realclean". Should
    be easy to fix, but it's got me wondering whether the dynamic declaration of
    dependencies is a good idea.

    - make man pages and install them. - append to perllocal.pod - write
    .packlist in appropriate location (needed for un-install)

AUTHOR
    Ken Williams, ken@mathforum.org

    Development questions, bug reports, and patches should be sent to the
    Module-Build mailing list at module-build-general@lists.sourceforge.net .

    An anonymous CVS repository containing the latest development version is
    available; see http://sourceforge.net/cvs/?group_id=45731 for the details of
    how to access it.

SEE ALSO
    perl(1), ExtUtils::MakeMaker(3), YAML(3)

    http://www.dsmit.com/cons/

